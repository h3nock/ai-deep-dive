---
title: "From Text to Bytes"
step: 1
description: "How computers represent language (Unicode & UTF-8)."

---

<Description>
  When you send a prompt to an LLM, the model doesn't see words or letters. It sees a sequence of numbers. Every piece of text, in every language, gets converted to numbers before a language model can process it. This chapter covers how that conversion works.
</Description>


<Step title="1. Text Representation">
  <Description>
    Computers only understand binary numbers (0s and 1s). To store or process text, we need a system that assigns a number to each character. As long as everyone agrees on the mapping, computers can use it to store and exchange text reliably.
  </Description>

  <Description>
    This consistency is achieved through **Unicode**, the universal standard for text. It acts as a large lookup table that assigns a unique number, called a **Code Point**, to every character in almost every language. Today, Unicode defines over 150,000 characters across 161 scripts. We usually represent these code points with the notation `U+XXXX` (where XXXX is a hexadecimal number).
  </Description>

  <Callout type="note" muted>
    Before Unicode, every region invented its own encoding. Americans used ASCII, Russians used KOI8, Japanese used Shift-JIS. A file written in one encoding looked like garbage when opened with another. Unicode solved this by providing a single universal standard.
  </Callout>

  <div style={{ marginTop: "var(--space-flow)", marginBottom: "var(--space-flow)" }}>
    <div className="text-xs font-medium text-muted uppercase tracking-wider mb-2">Examples of Unicode Code Point Mappings</div>

  | Character | Description | Unicode Code Point | Decimal Value |
  | :--- | :--- | :--- | :--- |
  | **A** | Latin Capital Letter A | `U+0041` | 65 |
  | **a** | Latin Small Letter a | `U+0061` | 97 |
  | **√©** | Latin 'e' with acute | `U+00E9` | 233 |
  | **·àÄ** | Amharic Letter Ha | `U+1200` | 4608 |
  | **‰∏≠** | Chinese "Middle" | `U+4E2D` | 20,013 |
  | **üòä** | Smiling Face | `U+1F60A` | 128,522 |
  </div>

  <Callout type="note" title="Important Distinction">
    Unicode only defines **which** number represents each character. It says nothing about **how** to store that number as bytes in memory. That's a separate decision called **encoding**, and it matters a lot for efficiency.
  </Callout>
</Step>

<Step title="2. Encoding">
  <Description>
    The simplest encoding would be to store every code point as a 4-byte (32-bit) integer, known as **UTF-32**. This handles any Unicode character easily, since even the largest code points fit in 4 bytes.
  </Description>

  <Description attached>
    However, UTF-32 is space-inefficient for most text. For example, a simple text file of English letters (which only need 1 byte) would be four times larger than necessary. Let's consider storing **"Hello"** using UTF-32:
  </Description>

  <div className="content-attached">

  | Character | Code Point | Stored in UTF-32 (Hex) |
  | :--- | :--- | :--- |
  | **H** | `U+0048` | `00 00 00 48` |
  | **e** | `U+0065` | `00 00 00 65` |
  | **l** | `U+006C` | `00 00 00 6C` |
  | **l** | `U+006C` | `00 00 00 6C` |
  | **o** | `U+006F` | `00 00 00 6F` |
  </div>

  <Description>
    For code points that don't require 4 bytes, the computer has to pad the remaining space with zeros. So, five characters require 20 bytes, but 15 of those bytes are zeros. That's 75% waste.
  </Description>

  <Description>
    For English text (which dominates the internet), UTF-32 uses four times more storage than necessary. This makes UTF-32 impractical for almost all real-world applications, so we need a more efficient encoding.
  </Description>
</Step>

<Step title="3. UTF-8: Variable-Width Encoding">
  <Description>
    **UTF-8** solves the storage problem with a clever idea: use fewer bytes for common characters and more bytes only when needed. Instead of wasting 4 bytes on every character, UTF-8 adapts based on the code point's size.
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.1 Byte Ranges by Character Type</h4>

  <Description attached>
    In UTF-8, different characters need different amounts of storage. ASCII characters (the basic Latin alphabet, digits, and punctuation) are so common that UTF-8 keeps them as single bytes for maximum efficiency. As characters become less common in English text (accented letters, then Asian scripts, then emoji), they get allocated more bytes. Here's how UTF-8 divides the Unicode space:
  </Description>

  <div className="content-attached grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
    <div className="p-4 rounded-lg bg-[#121212] border border-zinc-800">
      <div className="text-2xl font-semibold text-primary mb-1">1 Byte</div>
      <div className="text-sm text-secondary">ASCII characters</div>
      <div className="text-xs text-muted mt-2">A-Z, a-z, 0-9</div>
      <div className="font-mono text-xs mt-2 text-secondary">U+0000 to U+007F</div>
    </div>
    <div className="p-4 rounded-lg bg-[#121212] border border-zinc-800">
      <div className="text-2xl font-semibold text-primary mb-1">2 Bytes</div>
      <div className="text-sm text-secondary">Latin extensions, Greek, Cyrillic</div>
      <div className="text-xs text-muted mt-2">√©, √±, Œ©, –î</div>
      <div className="font-mono text-xs mt-2 text-secondary">U+0080 to U+07FF</div>
    </div>
    <div className="p-4 rounded-lg bg-[#121212] border border-zinc-800">
      <div className="text-2xl font-semibold text-primary mb-1">3 Bytes</div>
      <div className="text-sm text-secondary">CJK, Amharic, most scripts</div>
      <div className="text-xs text-muted mt-2">‰∏≠, Êó•, „Ñ±, ·àÄ</div>
      <div className="font-mono text-xs mt-2 text-secondary">U+0800 to U+FFFF</div>
    </div>
    <div className="p-4 rounded-lg bg-[#121212] border border-zinc-800">
      <div className="text-2xl font-semibold text-primary mb-1">4 Bytes</div>
      <div className="text-sm text-secondary">Emojis, rare scripts</div>
      <div className="text-xs text-muted mt-2">üòä, üöÄ, ìÄÄ</div>
      <div className="font-mono text-xs mt-2 text-secondary">U+10000 to U+10FFFF</div>
    </div>
  </div>

  <Description>
    With UTF-8, "Hello" takes just 5 bytes instead of 20. English text is as compact as it was with ASCII, while still supporting every character in Unicode.
  </Description>

  <Description>
    The difference becomes clear when you compare them side by side:
  </Description>

  <EncodingCompare />

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.2 Fixed vs Variable Width: The Parsing Challenge</h4>

  <Description>
    Variable-width encoding creates a problem that fixed-width encodings don't have: how do you know where one character ends and the next begins? With UTF-32, this is trivial: every character is exactly 4 bytes, so you just read bytes in fixed chunks of four. Let's see the difference visually.
  </Description>

  <div style={{ marginTop: "var(--space-flow)", marginBottom: "var(--space-flow)" }}>
    <h5 className="text-sm font-medium text-secondary mb-3">UTF-32: Fixed-width parsing</h5>
    <div className="font-mono text-xs bg-[#121212] p-4 rounded-lg border border-zinc-800 overflow-x-auto">
      <div className="text-muted mb-2">Byte stream for "A√©‰∏≠":</div>
      <div className="flex flex-wrap gap-1 mb-3">
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">41</span>
        <span className="text-muted mx-1">|</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">E9</span>
        <span className="text-muted mx-1">|</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">4E</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">2D</span>
      </div>
      <div className="text-muted">Every 4 bytes = 1 character. Simple.</div>
    </div>
  </div>

  <Description attached>
    But with UTF-8, characters have variable lengths (1, 2, or 3 bytes in this example). Looking at the same string encoded in UTF-8, we see fewer bytes total, but no obvious boundaries:
  </Description>

  <div className="content-attached">
    <h5 className="text-sm font-medium text-secondary mb-3">UTF-8: Variable-width... but where are the boundaries?</h5>
    <div className="font-mono text-xs bg-[#121212] p-4 rounded-lg border border-zinc-800 overflow-x-auto">
      <div className="text-muted mb-2">Byte stream for "A√©‰∏≠":</div>
      <div className="flex flex-wrap gap-1 mb-3">
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">41</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">C3</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">A9</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">E4</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">B8</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">AD</span>
      </div>
      <div className="text-muted">6 bytes total, but which bytes belong to which character?</div>
    </div>
  </div>

  <Description>
    This is the core challenge: when reading a stream of UTF-8 bytes, how does a computer know where one character ends and another begins? UTF-8 solves this with a clever bit pattern system.
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.3 The UTF-8 Bit Patterns</h4>

  <Description>
    UTF-8's brilliant solution is to embed the length information directly into each byte. The first few bits of every byte follow a strict pattern that tells you exactly what role that byte plays. Think of it like a prefix code: before the actual character data, each byte announces "I'm the start of a 2-byte character" or "I'm a continuation of the previous character."
  </Description>

  <Description attached>
    Here's the complete pattern. Pay attention to how the leading bits change:
  </Description>

  <div className="content-attached overflow-x-auto">
    <table className="w-full text-sm border border-border rounded-lg overflow-hidden">
      <thead className="bg-surface">
        <tr>
          <th className="text-left py-3 px-4 font-medium text-primary">Byte Count</th>
          <th className="text-left py-3 px-4 font-medium text-primary">First Byte Pattern</th>
          <th className="text-left py-3 px-4 font-medium text-primary">Continuation Bytes</th>
          <th className="text-left py-3 px-4 font-medium text-primary">Bits for Data</th>
        </tr>
      </thead>
      <tbody className="font-mono text-xs">
        <tr className="border-t border-border">
          <td className="py-3 px-4 font-sans">1 byte</td>
          <td className="py-3 px-4"><span className="text-emerald-400 font-semibold">0</span>xxxxxxx</td>
          <td className="py-3 px-4 text-muted">-</td>
          <td className="py-3 px-4 font-sans text-secondary">7 bits</td>
        </tr>
        <tr className="border-t border-border bg-surface">
          <td className="py-3 px-4 font-sans">2 bytes</td>
          <td className="py-3 px-4"><span className="text-emerald-400 font-semibold">110</span>xxxxx</td>
          <td className="py-3 px-4"><span className="text-muted">10</span>xxxxxx</td>
          <td className="py-3 px-4 font-sans text-secondary">11 bits</td>
        </tr>
        <tr className="border-t border-border">
          <td className="py-3 px-4 font-sans">3 bytes</td>
          <td className="py-3 px-4"><span className="text-emerald-400 font-semibold">1110</span>xxxx</td>
          <td className="py-3 px-4"><span className="text-muted">10</span>xxxxxx √ó 2</td>
          <td className="py-3 px-4 font-sans text-secondary">16 bits</td>
        </tr>
        <tr className="border-t border-border bg-surface">
          <td className="py-3 px-4 font-sans">4 bytes</td>
          <td className="py-3 px-4"><span className="text-emerald-400 font-semibold">11110</span>xxx</td>
          <td className="py-3 px-4"><span className="text-muted">10</span>xxxxxx √ó 3</td>
          <td className="py-3 px-4 font-sans text-secondary">21 bits</td>
        </tr>
      </tbody>
    </table>
  </div>

  <Description>
    The rule is elegantly simple: count the leading `1`s in the first byte to know how many bytes the character uses. A leading `0` means a single byte. `110` means two bytes. `1110` means three. `11110` means four. Continuation bytes always start with `10`, so they can never be mistaken for the start of a character.
  </Description>

  <Callout type="tip" title="Key Insight">
    This pattern ensures you can **never** confuse bytes. If you see a byte starting with `10`, you know it's a continuation. Keep reading backward or forward to find the leading byte. If you see `0`, `110`, `1110`, or `11110`, you're at the start of a character and know exactly how many bytes to read.
  </Callout>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.4 Decoding a Byte Stream</h4>

  <Description>
    Now let's apply these patterns to actually decode the UTF-8 byte stream we saw earlier. We'll go through each byte, check its leading bits to determine its role, and reconstruct the original characters. This is exactly what your computer does every time it reads a text file.
  </Description>

  <div className="my-6 font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
    <div className="text-xs font-medium text-muted uppercase tracking-wider mb-4">Bytes: 41 C3 A9 E4 B8 AD</div>
    
    <div className="space-y-4">
      {/* Character 1: A (1 byte) */}
      <div className="pl-4 border-l-2 border-zinc-600">
        <div className="text-secondary mb-1">
          <span className="font-semibold">41</span>
          <span className="mx-2">=</span>
          <span className="text-emerald-400">0</span>1000001
          <span className="text-muted text-xs ml-3">‚Üê starts with 0 ‚Üí single byte</span>
        </div>
        <div className="flex items-center gap-2 text-xs text-muted">
          <span>‚Üí</span>
          <span className="text-2xl">A</span>
        </div>
      </div>

      {/* Character 2: √© (2 bytes) */}
      <div className="pl-4 border-l-2 border-zinc-600">
        <div className="space-y-1 mb-1">
          <div className="text-secondary">
            <span className="font-semibold">C3</span>
            <span className="mx-2">=</span>
            <span className="text-emerald-400">110</span>00011
            <span className="text-muted text-xs ml-3">‚Üê <span className="text-emerald-400">two</span> 1s ‚Üí read 2 bytes</span>
          </div>
          <div className="text-secondary">
            <span className="font-semibold">A9</span>
            <span className="mx-2">=</span>
            <span className="text-zinc-600">10</span>101001
            <span className="text-muted text-xs ml-3">‚Üê continuation</span>
          </div>
        </div>
        <div className="flex items-center gap-2 text-xs text-muted">
          <span>‚Üí</span>
          <span className="text-2xl">√©</span>
        </div>
      </div>

      {/* Character 3: ‰∏≠ (3 bytes) */}
      <div className="pl-4 border-l-2 border-zinc-600">
        <div className="space-y-1 mb-1">
          <div className="text-secondary">
            <span className="font-semibold">E4</span>
            <span className="mx-2">=</span>
            <span className="text-emerald-400">1110</span>0100
            <span className="text-muted text-xs ml-3">‚Üê <span className="text-emerald-400">three</span> 1s ‚Üí read 3 bytes</span>
          </div>
          <div className="text-secondary">
            <span className="font-semibold">B8</span>
            <span className="mx-2">=</span>
            <span className="text-zinc-600">10</span>111000
            <span className="text-muted text-xs ml-3">‚Üê continuation</span>
          </div>
          <div className="text-secondary">
            <span className="font-semibold">AD</span>
            <span className="mx-2">=</span>
            <span className="text-zinc-600">10</span>101101
            <span className="text-muted text-xs ml-3">‚Üê continuation</span>
          </div>
        </div>
        <div className="flex items-center gap-2 text-xs text-muted">
          <span>‚Üí</span>
          <span className="text-2xl">‰∏≠</span>
        </div>
      </div>
    </div>
  </div>

  <Description>
    And there we have it! The boundaries are now clear: `[41] [C3 A9] [E4 B8 AD]` ‚Üí "A", "√©", "‰∏≠". Notice how we never had to guess. Each byte's leading bits told us exactly what to do. This self-describing property is what makes UTF-8 so robust: even if data gets corrupted or you start reading from the middle of a file, you can always find the next valid character boundary.
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.5 Encoding a Character to Bytes</h4>

  <Description>
    We've seen how to decode UTF-8, but how does the encoding process work in reverse? When your computer needs to save a character to a file, it must convert the Unicode code point into the correct sequence of bytes. Let's walk through this process step by step.
  </Description>

  <Description>
    We'll encode **√©** (U+00E9, decimal 233). First, we check which byte range it falls into: since 233 is larger than 127 but smaller than 2048, it needs 2 bytes. Now we need to split its bits and insert them into the UTF-8 template.
  </Description>

  <div className="my-6 space-y-4">
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Step 1: Convert code point to binary</h5>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
        233 in decimal = <span className="text-primary font-semibold">11101001</span> in binary (8 bits)
      </div>
    </div>
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Step 2: Split bits according to 2-byte template</h5>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
        <div className="text-muted mb-1">Template: 110xxxxx 10xxxxxx (5 bits + 6 bits = 11 bits)</div>
        <div className="text-muted mb-1">We need to fit: 11101001 (pad to 11 bits ‚Üí 00011101001)</div>
        <div>Split: <span className="text-emerald-400">00011</span> and <span className="text-emerald-400">101001</span></div>
      </div>
    </div>
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Step 3: Insert into UTF-8 template</h5>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
        <div>Byte 1: <span className="text-muted">110</span><span className="text-emerald-400">00011</span> = 11000011 = <span className="font-semibold">195 (0xC3)</span></div>
        <div>Byte 2: <span className="text-muted">10</span><span className="text-emerald-400">101001</span> = 10101001 = <span className="font-semibold">169 (0xA9)</span></div>
      </div>
    </div>
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Result</h5>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
        "√©" ‚Üí <span className="font-semibold">[195 (0xC3), 169 (0xA9)]</span>
      </div>
    </div>
  </div>
</Step>


<Step title="4. Complete Example">
  <Description>
    Let's trace through how **"Hi üëã"** gets converted to bytes. This is the exact process that happens before text reaches a language model. We'll show byte values in decimal here since that's what programming languages display by default.
  </Description>

  <div className="my-6 space-y-6">
    <div>
      <h4 className="font-semibold text-primary mb-3">Step 1: Look up each character's code point</h4>
      <div className="bg-[#121212] p-4 rounded-lg border border-zinc-800">
        <ul className="space-y-3 text-sm text-secondary">
          <li className="flex justify-between items-center">
            <span className="text-lg">H</span>
            <span className="font-mono text-primary">U+0048 (decimal 72)</span>
            <span className="text-xs px-2 py-1 bg-zinc-800 text-muted rounded">1-byte</span>
          </li>
          <li className="flex justify-between items-center">
            <span className="text-lg">i</span>
            <span className="font-mono text-primary">U+0069 (decimal 105)</span>
            <span className="text-xs px-2 py-1 bg-zinc-800 text-muted rounded">1-byte</span>
          </li>
          <li className="flex justify-between items-center">
            <span className="text-lg">(space)</span>
            <span className="font-mono text-primary">U+0020 (decimal 32)</span>
            <span className="text-xs px-2 py-1 bg-zinc-800 text-muted rounded">1-byte</span>
          </li>
          <li className="flex justify-between items-center">
            <span className="text-lg">üëã</span>
            <span className="font-mono text-primary">U+1F44B (decimal 128,075)</span>
            <span className="text-xs px-2 py-1 bg-zinc-800 text-muted rounded">4-byte</span>
          </li>
        </ul>
      </div>
    </div>

    <div>
      <h4 className="font-semibold text-primary mb-3">Step 2: Encode each code point to bytes</h4>
      <div className="text-sm text-secondary space-y-3">
        <p>The first three characters have code points below 128, so they map directly to single bytes: 72, 105, 32.</p>
        <p>The emoji's code point (128,075) requires 4-byte encoding. Using the same process we showed for "√©", the bits get distributed across four bytes following the `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` template, producing: 240 (0xF0), 159 (0x9F), 145 (0x91), 139 (0x8B).</p>
      </div>
    </div>

    <div>
      <h4 className="font-semibold text-primary mb-3">Step 3: The final byte sequence</h4>
      <ByteStream bytes={[72, 105, 32, 240, 159, 145, 139]} label="What the model sees" />
      <Description>
        Four characters became seven bytes. This sequence of integers is what text processing systems, including language models, actually receive as input. In Python, `list("Hi üëã".encode('utf-8'))` returns exactly this.
      </Description>
    </div>
  </div>
</Step>

<Step title="5. Interactive: Character to Bytes">
  <LiveByteInspector />
</Step>

<Step title="6. Why Not Train on Raw Bytes?">
  <Description>
    We have just spent this entire chapter establishing that UTF-8 is the universal standard for text. It can represent every language, every emoji, and every symbol using just 256 basic units (bytes).
  </Description>

  <Description>
    A very natural question arises: **Why don't we just feed these raw bytes directly into the model?**
  </Description>

  <Description>
    It seems like the perfect solution. It's **Universal**: you would never need to update your model for new languages since Spanish, Chinese, and Python code are all just bytes. It's also **Tiny**: the model would only need a vocabulary of 256 items, which is incredibly memory efficient compared to storing hundreds of thousands of words.
  </Description>

  <Description attached>
    Given how elegant this solution seems, **could we just train a model on raw bytes?** Let's think through the trade-offs:
  </Description>

  <ThinkingProcess 
    className="content-attached"
    title="Think About the Trade-off"
    hint={
      <div>
        <p className="text-secondary mb-4">Compare these two approaches:</p>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div className="p-4 bg-[#121212] rounded-lg border border-zinc-800">
            <strong className="text-primary">Byte-Level</strong>
            <ul className="list-disc pl-4 mt-2 text-sm text-zinc-400">
              <li>Vocabulary: 256</li>
              <li>"Hello" = 5 units</li>
              <li>"‰∫∫Â∑•Êô∫ËÉΩ" = 12 units</li>
            </ul>
          </div>
          <div className="p-4 bg-[#121212] rounded-lg border border-zinc-800">
            <strong className="text-primary">Word-Level</strong>
            <ul className="list-disc pl-4 mt-2 text-sm text-zinc-400">
              <li>Vocabulary: 500,000+</li>
              <li>"Hello" = 1 unit</li>
              <li>"‰∫∫Â∑•Êô∫ËÉΩ" = 1 unit</li>
            </ul>
          </div>
        </div>
        <p className="mt-4 text-sm text-muted">What problems does each approach create?</p>
      </div>
    }
  >
    <div className="space-y-8">
      <div>
        <h4 className="text-lg font-bold text-primary">Why Bytes Fail</h4>
        <p className="mt-3 text-base text-primary">
          The problem isn't what the model can read; the problem is <strong>how much attention it has to spend reading it</strong>.
        </p>
        <p className="mt-4 text-base text-primary">
          Imagine someone trying to tell you a story, but instead of speaking in words, they pronounced every single letter out loud:
        </p>
        <p style={{ marginTop: "var(--space-connected)", marginBottom: "var(--space-connected)" }} className="text-lg italic text-secondary pl-4 border-l-2 border-border">
          "T... H... E... Q... U... I... C... K... B... R... O... W... N... F... O... X..."
        </p>
        <p className="text-base text-primary">
          By the time they get to "F-O-X," you've already forgotten the beginning of the sentence. Your brain is so busy assembling letters into words that it has no capacity left to understand the actual meaning. When you read text on a page, your eyes can scan and group letters instantly. But when information arrives one piece at a time, like listening to someone speak, you must hold each piece in memory while waiting for the rest. This is the bottleneck.
        </p>
        <p className="mt-4 text-base text-primary">
          AI models face the exact same limitation. Large Language Models have a fixed <strong>Context Window</strong>: a hard limit on how many units of information they can hold in working memory at once.
        </p>
        <p className="mt-4 text-base text-primary">
          Consider the phrase "Artificial Intelligence". To a human, this is <strong>2</strong> concepts. To a byte-level model, it's <strong>23</strong> separate units to process. The model burns through its limited context window just to represent a single phrase. Worse, it has to re-learn that <code className="text-sm">t</code> followed by <code className="text-sm">h</code> followed by <code className="text-sm">e</code> usually means "the" over and over again. This is a massive waste of the model's capacity.
        </p>
      </div>

      <hr className="border-border" />

      <div>
        <h4 className="text-lg font-bold text-primary">Why Words Fail</h4>
        <p className="mt-3 text-base text-primary">
          So, why not go to the other extreme? Why not just give every word in the English language its own unique ID number?
        </p>
        <div style={{ marginTop: "var(--space-connected)", marginBottom: "var(--space-connected)" }} className="font-mono text-base bg-[#121212] p-4 rounded-lg border border-zinc-800">
          <div className="text-primary">"Apple" = 101</div>
          <div className="text-primary">"Banana" = 102</div>
          <div className="text-primary">"ChatGPT" = 103</div>
        </div>
        <p className="text-base text-primary">
          This solves the length problem (sequences become very short), but it creates a <strong>Vocabulary Problem</strong>:
        </p>
        <ul className="list-disc pl-5 mt-4 space-y-3 text-base text-primary">
          <li><strong>Size:</strong> English has over 500,000 words. Add medical terms, legal jargon, names, slang, and other languages, and you easily reach millions. The model's "dictionary" (the Embedding Table) becomes impossibly large to store in memory.</li>
          <li><strong>Fragility:</strong> What happens when the model encounters a word it has never seen? If you train a model today, and tomorrow a new term like "GPT-5" or "metaverse" appears, a word-level model simply breaks. It has no ID for that word and must output an <code className="text-sm">&lt;UNKNOWN&gt;</code> error.</li>
        </ul>
      </div>

      <hr className="border-border" />

      <div>
        <h4 className="text-lg font-bold text-primary">The Solution: Tokens</h4>
        <p className="mt-3 text-base text-primary">
          Neither extreme works. Bytes give us universality but waste context. Words give us efficiency but break on anything new. We need to find a balance between these two extremes.
        </p>
        <p className="mt-4 text-base text-primary">
          The insight is this: what if we could <strong>automatically learn</strong> which character sequences should be grouped together? Common patterns like "the", "ing", and "tion" appear so frequently that they deserve to be single units. But rare words like "cryptocurrency" can be broken into recognizable pieces: "crypto" + "currency".
        </p>
        <p className="mt-4 text-base text-primary">
          This is exactly what <strong>Tokenization</strong> does. In modern LLMs, we don't use words or bytes. We use <strong>Tokens</strong>: variable-sized chunks that are learned from data.
        </p>
        <ul className="list-disc pl-5 mt-4 space-y-2 text-base text-primary">
          <li>A common word like "apple" becomes a single token.</li>
          <li>A complex word like "tokenization" gets split into "token" + "ization".</li>
          <li>A rare word like "Anthropic" might become "Anthrop" + "ic".</li>
        </ul>
        <p className="mt-4 text-base text-primary">
          This gives us the best of both worlds. The model can process common text quickly (short sequences), but it can also handle any text in the universe by falling back to smaller pieces when needed. No more <code className="text-sm">&lt;UNKNOWN&gt;</code> errors. No more wasted context on individual bytes.
        </p>
      </div>
    </div>
  </ThinkingProcess>
</Step>

<Step title="7. Next: Tokenization">
  <Description>
    The algorithm that finds this middle ground is called **Byte Pair Encoding (BPE)**. It starts with individual bytes and iteratively merges the most frequent adjacent pairs. After training on a large text corpus, common patterns like "ing", "tion", and "the" become single units called **tokens**, while rare words get split into smaller recognizable pieces.
  </Description>

  <div style={{ marginTop: "var(--space-flow)", marginBottom: "var(--space-flow)" }}>
    <h5 className="text-sm font-medium text-muted mb-3">Preview: How GPT-4 tokenizes text</h5>
    <div className="bg-[#121212] p-4 rounded-lg border border-zinc-800 space-y-2 font-mono text-sm">
      <div className="flex items-center gap-2">
        <span className="text-secondary">"Hello" ‚Üí</span>
        <span className="px-2 py-1 bg-zinc-800 text-primary rounded">[Hello]</span>
        <span className="text-muted text-xs">(1 token)</span>
      </div>
      <div className="flex items-center gap-2 flex-wrap">
        <span className="text-secondary">"Unbelievable" ‚Üí</span>
        <span className="px-2 py-1 bg-zinc-800 text-primary rounded">[Un]</span>
        <span className="px-2 py-1 bg-zinc-800 text-primary rounded">[believ]</span>
        <span className="px-2 py-1 bg-zinc-800 text-primary rounded">[able]</span>
        <span className="text-muted text-xs">(3 tokens)</span>
      </div>
    </div>
  </div>

  <Callout type="success" title="Summary">
    * **Unicode** assigns a unique code point to every character in every writing system
    * **UTF-8** encodes those code points as variable-length byte sequences (1-4 bytes)
    * Raw **bytes** are universal but create sequences that are too long for efficient processing
    * Full **words** keep sequences short but require impossibly large vocabularies
    * We need something in between: **tokens**
  </Callout>

  <Description>
    In the next chapter, we'll build BPE from scratch and see exactly how models like GPT-4 convert text into the units they actually process.
  </Description>
</Step>
