---
title: "From Text to Bytes"
step: 1
description: "How computers represent language (Unicode & UTF-8)."

---

<Description>
  When you send a prompt to an LLM, the model doesn't see words or letters. It sees a sequence of numbers. Every piece of text, in every language, gets converted to numbers before a language model can process it. This chapter covers how that conversion works.
</Description>


<Step title="1. Text Representation">
  <Description>
    Computers only understand binary numbers (0s and 1s). To store or process text, we need a system that assigns a number to each character. As long as everyone agrees on the mapping, computers can use it to store and exchange text reliably.
  </Description>

  <Description>
    This consistency is achieved through **Unicode**, the universal standard for text. It acts as a large lookup table that assigns a unique number, called a **Code Point**, to every character in almost every language. Today, Unicode defines over 150,000 characters across 161 scripts. We usually represent these code points with the notation `U+XXXX` (where XXXX is a hexadecimal number).
  </Description>

  <Callout type="note" muted>
    Before Unicode, every region invented its own encoding. Americans used ASCII, Russians used KOI8, Japanese used Shift-JIS. A file written in one encoding looked like garbage when opened with another. Unicode solved this by providing a single universal standard.
  </Callout>

  <div style={{ marginTop: "var(--space-flow)", marginBottom: "var(--space-flow)" }}>
    <div className="text-xs font-medium text-muted uppercase tracking-wider mb-2">Examples of Unicode Code Point Mappings</div>

  | Character | Description | Unicode Code Point | Decimal Value |
  | :--- | :--- | :--- | :--- |
  | **A** | Latin Capital Letter A | `U+0041` | 65 |
  | **a** | Latin Small Letter a | `U+0061` | 97 |
  | **√©** | Latin 'e' with acute | `U+00E9` | 233 |
  | **·àÄ** | Amharic Letter Ha | `U+1200` | 4608 |
  | **‰∏≠** | Chinese "Middle" | `U+4E2D` | 20,013 |
  | **üòä** | Smiling Face | `U+1F60A` | 128,522 |
  </div>

  <Callout type="note" title="Important Distinction">
    Unicode only defines **which** number represents each character. It says nothing about **how** to store that number as bytes in memory. That's a separate decision called **encoding**, and it matters a lot for efficiency.
  </Callout>
</Step>

<Step title="2. Encoding">
  <Description>
    The simplest encoding would be to store every code point as a 4-byte (32-bit) integer, known as **UTF-32**. This handles any Unicode character easily, since even the largest code points fit in 4 bytes.
  </Description>

  <Description attached>
    However, UTF-32 is space-inefficient for most text. For example, a simple text file of English letters (which only need 1 byte) would be four times larger than necessary. Let's consider storing **"Hello"** using UTF-32:
  </Description>

  <div className="content-attached">

  | Character | Code Point | Stored in UTF-32 (Hex) |
  | :--- | :--- | :--- |
  | **H** | `U+0048` | `00 00 00 48` |
  | **e** | `U+0065` | `00 00 00 65` |
  | **l** | `U+006C` | `00 00 00 6C` |
  | **l** | `U+006C` | `00 00 00 6C` |
  | **o** | `U+006F` | `00 00 00 6F` |
  </div>

  <Description>
    For code points that don't require 4 bytes, the computer has to pad the remaining space with zeros. So, five characters require 20 bytes, but 15 of those bytes are zeros. That's 75% waste.
  </Description>

  <Description>
    For English text (which dominates the internet), UTF-32 uses four times more storage than necessary. This makes UTF-32 impractical for almost all real-world applications, so we need a more efficient encoding.
  </Description>
</Step>

<Step title="3. UTF-8">
  <Description>
    **UTF-8** solves the storage problem by using fewer bytes for common characters and more bytes only when needed, instead of wasting 4 bytes on every character.
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.1 How UTF-8 Allocates Bytes</h4>

  <Description attached>
    In UTF-8, different characters need different amounts of storage. ASCII characters (the basic Latin alphabet, digits, and punctuation) are so common that UTF-8 keeps them as single bytes for maximum efficiency. As characters become less common in English text (accented letters, then Asian scripts, then emoji), they get allocated more bytes. Here's how UTF-8 divides the Unicode space:
  </Description>

  <div className="content-attached grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
    <div className="p-4 rounded-lg bg-[#121212] border border-zinc-800">
      <div className="text-2xl font-semibold text-primary mb-1">1 Byte</div>
      <div className="text-sm text-secondary">ASCII characters</div>
      <div className="text-xs text-muted mt-2">A-Z, a-z, 0-9</div>
      <div className="font-mono text-xs mt-2 text-secondary">U+0000 to U+007F</div>
    </div>
    <div className="p-4 rounded-lg bg-[#121212] border border-zinc-800">
      <div className="text-2xl font-semibold text-primary mb-1">2 Bytes</div>
      <div className="text-sm text-secondary">Latin extensions, Greek, Cyrillic</div>
      <div className="text-xs text-muted mt-2">√©, √±, Œ©, –î</div>
      <div className="font-mono text-xs mt-2 text-secondary">U+0080 to U+07FF</div>
    </div>
    <div className="p-4 rounded-lg bg-[#121212] border border-zinc-800">
      <div className="text-2xl font-semibold text-primary mb-1">3 Bytes</div>
      <div className="text-sm text-secondary">CJK, Amharic, most scripts</div>
      <div className="text-xs text-muted mt-2">‰∏≠, Êó•, „Ñ±, ·àÄ</div>
      <div className="font-mono text-xs mt-2 text-secondary">U+0800 to U+FFFF</div>
    </div>
    <div className="p-4 rounded-lg bg-[#121212] border border-zinc-800">
      <div className="text-2xl font-semibold text-primary mb-1">4 Bytes</div>
      <div className="text-sm text-secondary">Emojis, rare scripts</div>
      <div className="text-xs text-muted mt-2">üòä, üöÄ, ìÄÄ</div>
      <div className="font-mono text-xs mt-2 text-secondary">U+10000 to U+10FFFF</div>
    </div>
  </div>

  <Description>
    With UTF-8, "Hello" takes just 5 bytes instead of 20. English text is as compact as it was with ASCII, while still supporting every character in Unicode. Try different text in the interactive comparison below to see how the byte counts change:
  </Description>

  <EncodingCompare />

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.2 Finding Character Boundaries</h4>

  <Description>
    Variable-width encoding creates a problem that fixed-width encodings don't have. How do you know where one character ends and the next begins? With UTF-32, every character is exactly 4 bytes, so you just read in fixed chunks of four. But with UTF-8, characters vary in length (1 to 4 bytes).
  </Description>

  <div style={{ marginTop: "var(--space-flow)", marginBottom: "var(--space-flow)" }}>
    <h5 className="text-sm font-medium text-secondary mb-3">UTF-32: Fixed-width parsing</h5>
    <div className="font-mono text-xs bg-[#121212] p-4 rounded-lg border border-zinc-800 overflow-x-auto">
      <div className="text-muted mb-2">Byte stream for "A√©‰∏≠":</div>
      <div className="flex flex-wrap gap-1 mb-3">
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">41</span>
        <span className="text-muted mx-1">|</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">E9</span>
        <span className="text-muted mx-1">|</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">00</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">4E</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">2D</span>
      </div>
      <div className="text-muted">Every 4 bytes = 1 character.</div>
    </div>
  </div>

  <Description attached>
    With UTF-8, the same string uses fewer bytes, but the boundaries aren't obvious:
  </Description>

  <div className="content-attached">
    <h5 className="text-sm font-medium text-secondary mb-3">UTF-8: Variable-width... but where are the boundaries?</h5>
    <div className="font-mono text-xs bg-[#121212] p-4 rounded-lg border border-zinc-800 overflow-x-auto">
      <div className="text-muted mb-2">Byte stream for "A√©‰∏≠":</div>
      <div className="flex flex-wrap gap-1 mb-3">
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">41</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">C3</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">A9</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">E4</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">B8</span>
        <span className="px-1.5 py-0.5 bg-zinc-800 rounded">AD</span>
      </div>
      <div className="text-muted">6 bytes total, but which bytes belong to which character?</div>
    </div>
  </div>

  <Description>
    This is the core challenge with variable-width encoding.
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.3 How UTF-8 Marks Boundaries</h4>

  <Description>
    UTF-8 solves the boundary problem by embedding length information directly into each byte's leading bits. The number of leading `1`s tells you how many bytes the character uses: a leading `0` means one byte, `110` means two, `1110` means three, and `11110` means four. Continuation bytes always start with `10`, so they can never be mistaken for the start of a new character.
  </Description>

  <Description attached>
    Here's the complete pattern:
  </Description>

  <div className="content-attached overflow-x-auto">
    <table className="w-full text-sm border border-border rounded-lg overflow-hidden">
      <thead className="bg-surface">
        <tr>
          <th className="text-left py-3 px-4 font-medium text-primary">Byte Count</th>
          <th className="text-left py-3 px-4 font-medium text-primary">First Byte Pattern</th>
          <th className="text-left py-3 px-4 font-medium text-primary">Continuation Bytes</th>
          <th className="text-left py-3 px-4 font-medium text-primary">Bits for Data</th>
        </tr>
      </thead>
      <tbody className="font-mono text-xs">
        <tr className="border-t border-border">
          <td className="py-3 px-4 font-sans">1 byte</td>
          <td className="py-3 px-4"><span className="text-emerald-400 font-semibold">0</span>xxxxxxx</td>
          <td className="py-3 px-4 text-muted">-</td>
          <td className="py-3 px-4 font-sans text-secondary">7 bits</td>
        </tr>
        <tr className="border-t border-border bg-surface">
          <td className="py-3 px-4 font-sans">2 bytes</td>
          <td className="py-3 px-4"><span className="text-emerald-400 font-semibold">110</span>xxxxx</td>
          <td className="py-3 px-4"><span className="text-muted">10</span>xxxxxx</td>
          <td className="py-3 px-4 font-sans text-secondary">11 bits</td>
        </tr>
        <tr className="border-t border-border">
          <td className="py-3 px-4 font-sans">3 bytes</td>
          <td className="py-3 px-4"><span className="text-emerald-400 font-semibold">1110</span>xxxx</td>
          <td className="py-3 px-4"><span className="text-muted">10</span>xxxxxx √ó 2</td>
          <td className="py-3 px-4 font-sans text-secondary">16 bits</td>
        </tr>
        <tr className="border-t border-border bg-surface">
          <td className="py-3 px-4 font-sans">4 bytes</td>
          <td className="py-3 px-4"><span className="text-emerald-400 font-semibold">11110</span>xxx</td>
          <td className="py-3 px-4"><span className="text-muted">10</span>xxxxxx √ó 3</td>
          <td className="py-3 px-4 font-sans text-secondary">21 bits</td>
        </tr>
      </tbody>
    </table>
  </div>

  <Callout type="tip" title="Key Insight">
    Any byte in a UTF-8 stream is self-identifying. A `10` prefix means continuation byte. A `0`, `110`, `1110`, or `11110` prefix means start of a character and tells you exactly how many bytes to read. You can jump to any position in a file and find the nearest character boundary.
  </Callout>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.4 Decoding</h4>

  <Description>
    Decoding converts bytes back into characters. For the UTF-8 byte stream from earlier, we read each byte's leading bits to determine whether it starts a new character or continues the previous one.
  </Description>

  <div className="my-6 font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
    <div className="text-xs font-medium text-muted uppercase tracking-wider mb-4">Bytes: 41 C3 A9 E4 B8 AD</div>
    
    <div className="space-y-4">
      {/* Character 1: A (1 byte) */}
      <div className="pl-4 border-l-2 border-zinc-600">
        <div className="text-secondary mb-1">
          <span className="font-semibold">41</span>
          <span className="mx-2">=</span>
          <span className="text-emerald-400">0</span>1000001
          <span className="text-muted text-xs ml-3">‚Üê starts with 0 ‚Üí single byte</span>
        </div>
        <div className="flex items-center gap-2 text-xs text-muted">
          <span>‚Üí</span>
          <span className="text-2xl">A</span>
        </div>
      </div>

      {/* Character 2: √© (2 bytes) */}
      <div className="pl-4 border-l-2 border-zinc-600">
        <div className="space-y-1 mb-1">
          <div className="text-secondary">
            <span className="font-semibold">C3</span>
            <span className="mx-2">=</span>
            <span className="text-emerald-400">110</span>00011
            <span className="text-muted text-xs ml-3">‚Üê <span className="text-emerald-400">two</span> 1s ‚Üí read 2 bytes</span>
          </div>
          <div className="text-secondary">
            <span className="font-semibold">A9</span>
            <span className="mx-2">=</span>
            <span className="text-zinc-600">10</span>101001
            <span className="text-muted text-xs ml-3">‚Üê continuation</span>
          </div>
        </div>
        <div className="flex items-center gap-2 text-xs text-muted">
          <span>‚Üí</span>
          <span className="text-2xl">√©</span>
        </div>
      </div>

      {/* Character 3: ‰∏≠ (3 bytes) */}
      <div className="pl-4 border-l-2 border-zinc-600">
        <div className="space-y-1 mb-1">
          <div className="text-secondary">
            <span className="font-semibold">E4</span>
            <span className="mx-2">=</span>
            <span className="text-emerald-400">1110</span>0100
            <span className="text-muted text-xs ml-3">‚Üê <span className="text-emerald-400">three</span> 1s ‚Üí read 3 bytes</span>
          </div>
          <div className="text-secondary">
            <span className="font-semibold">B8</span>
            <span className="mx-2">=</span>
            <span className="text-zinc-600">10</span>111000
            <span className="text-muted text-xs ml-3">‚Üê continuation</span>
          </div>
          <div className="text-secondary">
            <span className="font-semibold">AD</span>
            <span className="mx-2">=</span>
            <span className="text-zinc-600">10</span>101101
            <span className="text-muted text-xs ml-3">‚Üê continuation</span>
          </div>
        </div>
        <div className="flex items-center gap-2 text-xs text-muted">
          <span>‚Üí</span>
          <span className="text-2xl">‰∏≠</span>
        </div>
      </div>
    </div>
  </div>

  <Description>
    The boundaries are now clear: `[41] [C3 A9] [E4 B8 AD]` ‚Üí "A", "√©", "‰∏≠". Each byte's leading bits told us exactly what to do, with no guessing required.
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>3.5 Encoding</h4>

  <Description>
    Encoding works in the opposite direction. Given a Unicode code point, we determine how many bytes it needs, then split its bits into the appropriate UTF-8 template.
  </Description>

  <Description>
    Let's encode **√©** (U+00E9, decimal 233). First, we determine how many bytes it needs by checking its value: 233 falls between 128 and 2047, so it requires the 2-byte template.
  </Description>

  <div className="my-6 space-y-4">
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Step 1: Convert code point to binary</h5>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
        233 in decimal = <span className="text-primary font-semibold">11101001</span> in binary (8 bits)
      </div>
    </div>
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Step 2: Count the available data slots</h5>
      <div className="text-sm text-secondary mb-3">
        Each byte reserves some bits for the prefix, leaving the rest as "slots" for our actual data:
      </div>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800 space-y-1">
        <div className="text-muted">Byte 1: <span className="text-emerald-400">110</span>xxxxx ‚Üí 5 data slots</div>
        <div className="text-muted">Byte 2: <span className="text-emerald-400">10</span>xxxxxx ‚Üí 6 data slots</div>
        <div className="text-muted">Total: 5 + 6 = 11 data slots to fill</div>
      </div>
    </div>
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Step 3: Pad the binary to fill all slots</h5>
      <div className="text-sm text-secondary mb-3">
        Our binary <code className="text-primary">11101001</code> has only 8 bits, so we pad it with leading zeros to fill all 11 slots:
      </div>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
        <div className="text-muted">11101001 (8 bits) ‚Üí <span className="text-secondary">000</span>11101001 (11 bits)</div>
      </div>
    </div>
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Step 4: Split and add prefix bits</h5>
      <div className="text-sm text-secondary mb-3">
        We split from the right to fill each byte's slots, then prepend the prefix bits:
      </div>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800 space-y-1">
        <div className="text-muted">Split from right: 00011 (5 bits) | 101001 (6 bits)</div>
        <div className="mt-2">Byte 1: <span className="text-emerald-400">110</span> + 00011 = 11000011 = <span className="font-semibold">195 (0xC3)</span></div>
        <div>Byte 2: <span className="text-emerald-400">10</span> + 101001 = 10101001 = <span className="font-semibold">169 (0xA9)</span></div>
      </div>
    </div>
    <div>
      <h5 className="text-sm font-medium text-primary mb-2">Result</h5>
      <div className="font-mono text-sm bg-[#121212] p-4 rounded-lg border border-zinc-800">
        "√©" ‚Üí <span className="font-semibold">[195 (0xC3), 169 (0xA9)]</span>
      </div>
    </div>
  </div>
</Step>


<Step title="4. Complete Example">
  <Description>
    Let's trace through how **"Hi üëã"** gets converted to bytes.
  </Description>

  <div className="my-6 space-y-6">
    <div>
      <h4 className="font-semibold text-primary mb-3">Step 1: Look up each character's code point</h4>
      <div className="bg-[#121212] p-4 rounded-lg border border-zinc-800">
        <ul className="space-y-3 text-sm text-secondary">
          <li className="flex justify-between items-center">
            <span className="text-lg">H</span>
            <span className="font-mono text-primary">U+0048 (72)</span>
            <span className="text-xs px-2 py-1 bg-zinc-800 text-muted rounded">1-byte</span>
          </li>
          <li className="flex justify-between items-center">
            <span className="text-lg">i</span>
            <span className="font-mono text-primary">U+0069 (105)</span>
            <span className="text-xs px-2 py-1 bg-zinc-800 text-muted rounded">1-byte</span>
          </li>
          <li className="flex justify-between items-center">
            <span className="text-lg">(space)</span>
            <span className="font-mono text-primary">U+0020 (32)</span>
            <span className="text-xs px-2 py-1 bg-zinc-800 text-muted rounded">1-byte</span>
          </li>
          <li className="flex justify-between items-center">
            <span className="text-lg">üëã</span>
            <span className="font-mono text-primary">U+1F44B (128075)</span>
            <span className="text-xs px-2 py-1 bg-zinc-800 text-muted rounded">4-byte</span>
          </li>
        </ul>
      </div>
    </div>

    <div>
      <h4 className="font-semibold text-primary mb-3">Step 2: Encode to bytes</h4>
      <div className="text-sm text-secondary">
        <p>The first three characters have code points below 128, so they map directly to single bytes: 72, 105, 32. The emoji (code point 128075) requires 4-byte encoding. Following the same process from section 3.5, we use the <code className="text-primary">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code> template, producing: 240, 159, 145, 139.</p>
      </div>
    </div>

    <div>
      <h4 className="font-semibold text-primary mb-3">Step 3: The final byte sequence</h4>
      <ByteStream bytes={[72, 105, 32, 240, 159, 145, 139]} />
      <Description>
        Our four characters became seven bytes. You can verify this with <code className="text-sm">list("Hi üëã".encode('utf-8'))</code> in Python.
      </Description>
    </div>
  </div>
</Step>

<Step title="5. Interactive: Character to Bytes">
  <LiveByteInspector />
</Step>

<Step title="6. Why Not Train on Raw Bytes?">
  <Description>
    We've now seen how UTF-8 converts any text into a sequence of bytes. Every language, every emoji, every symbol reduces to just 256 possible byte values. So why not feed these raw bytes directly into an AI model?
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>The Problem with Bytes</h4>

  <Description>
    The issue isn't what the model can read, but **how much attention it has to spend reading it**. Imagine someone telling you a story by pronouncing every letter:
  </Description>

  <p style={{ marginTop: "var(--space-connected)", marginBottom: "var(--space-connected)" }} className="text-lg italic text-secondary pl-4 border-l-2 border-border">
    "T... H... E... Q... U... I... C... K... B... R... O... W... N... F... O... X..."
  </p>

  <Description>
    By the time they reach "F-O-X," you've forgotten the beginning. Your brain is so busy assembling letters that it has no capacity left for meaning.
  </Description>

  <Description>
    AI models face a similar challenge. They process text sequentially, one unit at a time, and can only hold so many units in memory. This limit is called the **Context Window**. When each byte is a separate unit, sequences become very long. For example, "Artificial Intelligence" is just 2 words to us, but 23 separate bytes for the model. Most of its capacity gets spent on low-level details instead of meaning.
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>What About Words?</h4>

  <Description>
    The opposite extreme is to give every word its own ID: "Apple" = 101, "Banana" = 102. This keeps sequences short, but creates new problems. First, the **vocabulary becomes huge**. To cover all languages, names, and technical terms, we'd need millions of IDs, consuming massive amounts of memory during training. Second, the **vocabulary is rigid**. When a new term like "GPT-8" is invented, the model has no ID for it and fails to process it.
  </Description>

  <h4 className="text-lg font-semibold text-primary" style={{ marginTop: 'var(--space-flow)', marginBottom: 'var(--space-atomic)' }}>The Solution: Tokens</h4>

  <Description>
    So bytes give us sequences that are too long, and words give us vocabularies that are too large. The middle ground is to start with bytes and merge adjacent ones based on frequency. For instance, the bytes for 't', 'h', and 'e' appear together so often that it's efficient to merge them into a single unit, called a **token**. Same with common words like "apple", "run", or suffixes like "ing". Rare words like "cryptocurrency" stay as separate pieces like "crypto" + "currency".
  </Description>

  <Description>
    This gives us the best of both worlds. Common text stays compact and efficient, while any new or rare word can be built from smaller, known pieces.
  </Description>
</Step>

<Step title="7. Next: Tokenization">
  <Description>
    We now have the right concept: common words should be single units, and rare words should be split. This process of chunking text into pieces is called **Tokenization**, and the resulting pieces are called **tokens**.
  </Description>

  <div style={{ marginTop: "var(--space-flow)", marginBottom: "var(--space-flow)" }}>
    <h5 className="text-sm font-medium text-muted mb-3">Preview: Tokenization in action</h5>
    <div className="bg-[#121212] p-4 rounded-lg border border-zinc-800 space-y-2 font-mono text-sm">
      <div className="flex items-center gap-2">
        <span className="text-secondary">"Hello" ‚Üí</span>
        <span className="px-2 py-1 bg-zinc-800 text-primary rounded">[Hello]</span>
        <span className="text-muted text-xs">(1 token)</span>
      </div>
      <div className="flex items-center gap-2 flex-wrap">
        <span className="text-secondary">"Unbelievable" ‚Üí</span>
        <span className="px-2 py-1 bg-zinc-800 text-primary rounded">[Un]</span>
        <span className="px-2 py-1 bg-zinc-800 text-primary rounded">[believ]</span>
        <span className="px-2 py-1 bg-zinc-800 text-primary rounded">[able]</span>
        <span className="text-muted text-xs">(3 tokens)</span>
      </div>
    </div>
  </div>

  <Callout type="success" title="Summary">
    * **Unicode** assigns a unique number (code point) to every character
    * **UTF-8** encodes those numbers efficiently into bytes
    * Raw **bytes** are too granular (wasting model attention)
    * **Words** are too sparse (huge vocabularies)
    * **Tokens** are the middle ground: frequent patterns merged into single units
  </Callout>

  <Description>
    In the next chapter, we'll build the algorithm that finds these optimal tokens: **Byte Pair Encoding (BPE)**.
  </Description>
</Step>
